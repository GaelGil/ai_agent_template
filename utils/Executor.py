from utils.schemas import Plan, PlannerTask
from MCP.client import MCPClient


class Executor:
    """Executor Class.

    Methods:
        print_task: Print the given task generated by the planner agent
        print_plan: Print the given plan generated by the planner agent
        call_tool: Call the tools
        execute_task: Execute the given task generated by the planner agent
        asemble_content: Assemble the content
        extract_tools: Extract the tools
        execute_plan: Execute the given plan generated by the planner agent

    Attributes:
        mcp_client: The mcp client, used to call tools
        tool_call_history: The history of tool calls
        previous_task_results: The results of the previous task

    """

    def __init__(self, mcp_client: MCPClient):
        """
        Initialize the Executor instance

        Args:
            mcp_client: The mcp client, used to call tools

        Returns:
            None
        """
        self.mcp_client = mcp_client
        self.tool_call_history: list = []
        self.previous_task_results: list = [{"first task, no previous task yet"}]

    def print_task(self, task: PlannerTask) -> None:
        """Print the given task generated by the planner agent

        Args:
            task: The task to print.

        Returns:
            None
        """
        print(f"""
              Executing task: \n
              Task ID: {task.id} \n
              Task description: {task.description} \n
              Tool calls: {task.tool_calls} \n
              Task status: {task.status} \n
              Previous Task Results: {self.previous_task_results}
        """)

    def print_plan(self, plan: Plan) -> None:
        """Print the given plan generated by the planner agent

        Args:
            plan: The plan to print.

        Returns:
            None
        """
        print(f"""
              Plan to execute is: \n
              Plan ID: {plan.original_query}
              Plan Description: {plan.description}
         """)

    async def call_tool(self, tool_calls: list[dict]) -> list[dict]:
        """Receives a list of tool calls and calls the tools

        Args:
            tool_calls: Either a list of tool call dicts or a string error message

        Returns:
            list[dict]: The results of the tool calls or error information
        """
        # If we received an error message instead of tool calls
        if isinstance(tool_calls, str):
            return [{"error": True, "message": tool_calls}]

        # # Ensure tool_calls is a list
        if not isinstance(tool_calls, list):
            return [
                {
                    "error": True,
                    "message": f"Expected list of tool calls, got {type(tool_calls).__name__}",
                }
            ]
        results = []  # Hold tool call results
        for tool in tool_calls:  # For each tool
            try:  # Try to call the tool
                if not isinstance(tool, dict):  # If tool is not a dict return error
                    results.append(
                        {
                            "error": True,
                            "message": f"Expected dict, got {type(tool).__name__}",
                        }
                    )
                    continue
                # Extract tool name and arguments
                name = tool["name"]  # str
                arguments = tool["arguments"]  # dict
                # If tool name is missing return error
                if not name:
                    results.append(
                        {"error": True, "message": "Tool call missing 'name' field"}
                    )
                    continue

                # Call the tool through MCP client
                result = await self.mcp_client.call_tool(name, arguments)
                # append tool call reults. Includes name, arguments, and result
                results.append({"result": result})
                self.tool_call_history.append(
                    {
                        "name": name,
                        "arguments": arguments,
                        "result": result,
                        "error": False,
                    }
                )

            # Handle exceptions
            except Exception as e:
                results.append(
                    {
                        "error": True,
                        "name": name if "name" in locals() else "unknown",
                        "message": f"Error calling tool: {str(e)}",
                    }
                )
        return results

    async def execute_task(self, task: PlannerTask) -> list[dict]:
        """Execute the given task generated by the planner agent

        Args:
            task: The task to execute.

        Returns:
            A list of results, each containing:
                - name: The name of the tool called.
                - arguments: The arguments passed to the tool.
                - result: The result of the tool call.
                - error: A boolean indicating whether an error occurred.
        """
        self.print_task(task)  # Print current task
        tool_calls = []  # Hold tool_calls in current task
        for i in range(len(task.tool_calls)):  # for every tool call in the task
            tool_call = task.tool_calls[i]  # select the tool call
            tools = self.extract_tools(
                tool_call
            )  # extract the tool into {name: tool_name, arguments: {...}}
            tool_calls.append(tools)  # add tool to tool_Calls list

        tool_call_results = await self.call_tool(
            tool_calls
        )  # call the tools, should return [{'result': result} ...]
        results = [
            result["result"] for result in tool_call_results
        ]  # extract the results
        return results

    def assemble_content(self) -> str:
        """
        Assemble the from the previous task results

        Returns:
            str: The assembled content
        """
        paragraphs = []
        for entry in self.previous_task_results:
            if isinstance(entry, dict):
                for res in entry.get("results", []):
                    if isinstance(res, str) and res.strip():
                        paragraphs.append(res.strip())
        return "\n\n".join(paragraphs)

    def extract_tools(self, tool_call):
        """Extract the tool into {name: tool_name, arguments: {...}}

        Args:
            tool_call: The tool call to extract.

        Returns:
            dict: The extracted tool.
        """
        name = tool_call.name.split(".")[-1]  # get name
        tool = {"name": name, "arguments": {}}  # set name and empty args
        # Select the keys (name of the argument)
        tool_call_keys = tool_call.arguments.keys
        # Select the values (value of the argument)
        tool_call_values = tool_call.arguments.values
        # Since same length only iterate one list
        for i in range(len(tool_call_values)):  # for each argument
            # if name is review_tool or assemble_content
            if name == "review_tool" or name == "assemble_content":
                # assemble content
                content = self.assemble_content()
                # pass the content as the content argument (otherwise is empty)
                tool["arguments"]["content"] = content
                # pass the previous_task results as context argument (otherwise is empty)
                tool["arguments"]["context"] = str(self.previous_task_results)
            else:
                # add the key-value pair ({arg1: value1, ..., argn: valuen})
                tool["arguments"][tool_call_keys[i]] = tool_call_values[i]

        return tool

    async def execute_plan(self, plan: Plan) -> list:
        """Execute the given plan generated by the planner agent

        Args:
            plan: The plan to execute.

        Returns:
            A list of results
        """
        self.print_plan(plan)  # print the plan
        results = ["no context yet"]  # list to hold results of each task execution.
        for i in range(len(plan.tasks)):  # iterate through tasks
            task: PlannerTask = plan.tasks[i]  # select the task
            res = await self.execute_task(task)  # execute task
            # append task execution results to list
            self.previous_task_results.append(
                {
                    "task": task.description,
                    "results": res,
                }
            )

        return results
