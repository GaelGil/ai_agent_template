from openai import OpenAI
from MCP.client import MCPClient
from utils.schemas import Plan, PlannerTask, ToolCalls, ToolCall


class OrchestratorAgent:
    """OrchestratorAgent class.

    Methods:


    Attributes:


    """

    def __init__(
        self,
        dev_prompt: str,
        mcp_client: MCPClient,
        llm: OpenAI,
        messages: list[dict],
        tools: list[dict],
        model_name: str = "gpt-4.1-mini",
    ):
        """
        Initialize the OrchestratorAgent.

        Args:
            dev_prompt (str): The developer prompt.
            mcp_client (MCPClient): The MCP client.
            llm (OpenAI): The LLM client.
            messages (list[dict]): The input messages.
            tools (list[dict]): The tools.
            model_name (str): The name of the model.
        """
        self.model_name = model_name
        self.dev_prompt = dev_prompt
        self.mcp_client = mcp_client
        self.llm = llm
        self.messages = messages
        self.tools = tools
        if self.dev_prompt:
            self.messages.append({"role": "developer", "content": self.dev_prompt})

    async def call_tool(self, tool_calls: list[dict]) -> list[dict]:
        """Receives a list of tool calls and calls the tools

        Args:
            tool_calls: Either a list of tool call dicts or a string error message

        Returns:
            list[dict]: The results of the tool calls or error information
        """
        # If we received an error message instead of tool calls
        if isinstance(tool_calls, str):
            return [{"error": True, "message": tool_calls}]

        # Ensure tool_calls is a list
        if not isinstance(tool_calls, list):
            return [
                {
                    "error": True,
                    "message": f"Expected list of tool calls, got {type(tool_calls).__name__}",
                }
            ]

        results = []  # Tool call results
        for tool in tool_calls:  # For each tool
            try:  # Try to call the tool
                if not isinstance(tool, dict):  # If tool is not a dict return error
                    results.append(
                        {
                            "error": True,
                            "message": f"Expected dict, got {type(tool).__name__}",
                        }
                    )
                    continue
                # Extract tool name and arguments
                name = tool.get("name")
                args = tool.get("arguments", {})

                # If tool name is missing return error
                if not name:
                    results.append(
                        {"error": True, "message": "Tool call missing 'name' field"}
                    )
                    continue

                # Call the tool through MCP client
                result = await self.mcp_client.call_tool(name, args)
                # append tool call reults. Includes name, arguments, and result
                results.append(
                    {"name": name, "arguments": args, "result": result, "error": False}
                )

            # Handle exceptions
            except Exception as e:
                results.append(
                    {
                        "error": True,
                        "name": name if "name" in locals() else "unknown",
                        "message": f"Error calling tool: {str(e)}",
                    }
                )

        # return results
        return results

    def call_tools(self, tool_calls: list[ToolCall]) -> list[dict]:
        """Receives a list of tool calls and calls the tools

        Args:
            tool_calls: Either a list of tool call dicts or a string error message

        Returns:
            list[dict]: The results of the tool calls or error information
        """
        # If we received an error message instead of tool calls
        if isinstance(tool_calls, str):
            return [{"error": True, "message": tool_calls}]

        # Ensure tool_calls is a list
        if not isinstance(tool_calls, list):
            return [
                {
                    "error": True,
                    "message": f"Expected list of tool calls, got {type(tool_calls).__name__}",
                }
            ]

        results: list[dict] = []
        for i in range(len(tool_calls)):
            tool_call = tool_calls[i]
            result = self.mcp_client.call_tool(tool_call.name, tool_call.arguments)
            result.append(
                {
                    "name": tool_call.name,
                    "arguments": tool_call.arguments,
                    "result": result,
                }
            )
        # Call the tools
        return results

    async def execute_task(
        self, task: PlannerTask, previous_task_results: list
    ) -> list[dict]:
        """Execute the given task generated by the planner agent

        Args:
            task: The task to execute.

        Returns:
            A list of results, each containing:
                - name: The name of the tool called.
                - arguments: The arguments passed to the tool.
                - result: The result of the tool call.
                - error: A boolean indicating whether an error occurred.
        """
        task_id = task.id
        task_description = task.description
        tool_suggestions = task.tool_suggestions
        task_status = task.status

        self.print_task(task, previous_task_results)

        messages = [
            {"role": "assistant", "content": str(task_id)},
            {"role": "assistant", "content": f"Tool suggestions: {tool_suggestions}"},
            {"role": "assistant", "content": f"Task status: {task_status}"},
            {
                "role": "assistant",
                "content": f"Previous Task Results: {previous_task_results}",
            },
            {
                "role": "user",
                "content": f"You must execute the following task: {task_description}",
            },
        ]

        response = self.llm.responses.parse(
            model=self.model_name,
            input=messages,
            tools=self.tools,
            tool_choice="auto",
            text_format=ToolCalls,
        )

        results = response
        return results

    def print_task(self, task: PlannerTask, previous_task_results: list) -> None:
        """Print the given task generated by the planner agent

        Args:
            task: The task to print.
            previous_task_results: The results of the previous task.

        Returns:
            None
        """
        print(f"""
              Executing task: \n
              Task ID: {task.id} \n
              Task description: {task.description} \n
              Tool suggestions: {task.tool_suggestions} \n
              Task status: {task.status} \n
              Previous Task Results: {previous_task_results}
        """)

    def print_plan(self, plan: Plan) -> None:
        """Print the given plan generated by the planner agent

        Args:
            plan: The plan to print.

        Returns:
            None
        """
        print(f"""
              Plan to execute is: \n
              Plan ID: {plan.original_query}
              Plan Description: {plan.description}
         """)

    async def execute_plan(self, plan: Plan) -> list:
        """Execute the given plan generated by the planner agent

        Args:
            plan: The plan to execute.

        Returns:
            A list of results
        """
        self.print_plan(plan)
        results = []
        prev_task_results = ""
        print(f"PLAN: {plan}")
        print(f"PLAN TYPE: {type(plan)}")
        print(f"PLAN.TASKS TYPE: {type(plan.tasks)}")
        for i in range(len(plan.tasks)):
            task: PlannerTask = plan.tasks[i]
            res = await self.execute_task(task, prev_task_results)
            results.append(res)
            prev_task_results = res
            break

        return results
